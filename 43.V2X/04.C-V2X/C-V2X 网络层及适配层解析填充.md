- [C-V2X 网络层及适配层解析填充_MCNS_37的博客-CSDN博客](https://blog.csdn.net/qq_35308053/article/details/115091699?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-14-115091699.pc_agg_new_rank&utm_term=v2x协议栈&spm=1000.2123.3001.4430)

# 一、适配层

  适配层提供底层接入技术与上层协议栈之间的传输适配功能。其中，适配层接收上层发送的DSMP 数据包、IP 数据包或DME 数据包，区分待发送数据包所使用的底层接入技术，并将相应数据包递交到符合对应接入技术的底层进行传输；或接收来自底层的数据包，区分相应数据包所属的上层协议类型，并将数据包递交给指定的上层协议栈。
  合作式智能运输系统专用短程通信网络层业务需支持无连接无确认的LLC 操作、子网接入协议和IP 数据报传输协议。
  适配层帧格式如下图所示，适配层帧包含适配层帧头以及适配层有效载荷两部分。适配层有效载荷用于封装上层数据包。适配层帧格式中的比特顺序为高位在前（大端模式）。
![适配层描述](https://img-blog.csdnimg.cn/20210322194748164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzA4MDUz,size_16,color_FFFFFF,t_70)
  其中协议类型（Protocol Type），用于指示上层数据包所使用的协议类型，目前所用的为DSMP协议，即“04”，具体见下表：

| 取值  | 协议类型（Protocol Type） |
| ----- | ------------------------- |
| 0     | IPV6                      |
| 1     | 保留                      |
| 2     | 保留                      |
| 3     | 保留                      |
| 4     | DSMP协议                  |
| 5     | IPV4                      |
| 6~255 | 保留                      |

# 二、网络层（DSMP）

  DSMP协议即专用短程通信短消息协议，关于DSM消息的逐层定义如下图所示：
![DSM逐层打包](https://img-blog.csdnimg.cn/20210322200022675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzA4MDUz,size_16,color_FFFFFF,t_70)
  DSM 的数据帧格式见下表。DSM 数据帧格式中的比特顺序为高位在前（大端模式）。

| 字段一       | 字段二                | 字段三   | 字段四    | 字段五   | 字段六   | 字段七 |
| ------------ | --------------------- | -------- | --------- | -------- | -------- | ------ |
| 3 bits       | 1bit                  | 4bits    | Var       | Var      | 2octets  | var    |
| DSMP Version | DSMP Option Indicator | Reserved | Extension | AID      | Length   | Data   |
| DSMP 版本    | DSMP 可选域指示       | 预留     | 扩展域    | 应用标识 | 数据长度 | 数据   |

  注1： DSMP 版本（Version），区分不同的DSMP 版本号（0～7）。本标准中DSMP 版本取值为0。   注2： DSMP 可选域指示（DSMP Option Indicator），取值为1 表示后面的扩展域出现，取值为0 表示后面的扩展域不出现。   注3：预留域（Reserved），预留比特，此版本全部取0。   注4：扩展域（Extension），预留可用于其它信息，包含其它信息标识、其它信息长度和其它信息内容三部分，其它信息标识就是Element ID，具体见5.2.3.3 节。扩展域长度、内容等信息将与标准版本相关联。    注5：应用标识（Application ID，AID），应用服务商的应用标识，区分不同的应用。   注6：数据长度（Length），表示应用层数据实体的字节长度。   注7：数据（Data），是承载的应用层或管理子层数据实体。

  其中字段一至四填0x00即可，字段五AID应用标识用于区分不同的应用，详见下表：

| AID  | 应用领域或其它描述                    | 消息      |
| ---- | ------------------------------------- | --------- |
| 17   | 在“四跨”活动前所有的应用标识均为17    | -         |
| 111  | 车车基本安全应用-普通车辆状态         | BSM,常规  |
| 112  | 车车基本安全应用-普通车辆关键事件提醒 | BSM，事件 |
| 113  | 车车基本安全应用-紧急车辆状态         | BSM，常规 |
| 114  | 车车基本安全应用-紧急车辆关键时间提醒 | BSM，事件 |
| 3617 | 车车基本安全应用-后装车载终端         | BSM       |
| 3618 | 地图类应用                            | MAP       |
| 3619 | 信号灯类应用                          | SPAT      |
| 3620 | 道路信息-静态类应用                   | RSI       |
| 3621 | 道路信息-半静态应用                   | RSI       |
| 3622 | 道路信息-动态应用                     | RSI       |
| 3623 | 道路提醒类应用                        | RSM       |

  需要注意的是，AID 采用变长字节表示形式，目前最多支持2 个字节的表示，最少采用1 个字节表示，方式见下表：

| 字节0的最高两位（x表示不关心）b7 b6 | AID长度（byte |
| ----------------------------------- | ------------- |
| 0 x                                 | 1             |
| 1 0                                 | 2             |
| 1 1                                 | >=3 保留      |

  如上表中AID区分，对于“车车基本安全应用-普通车辆状态”，即aid为111，填充aid时则填充0x6F;而对于“地图类应用”，即aid为3618，填充aid时则应填充为0x8E22，其中字节0的前两位“10”表示aid长度为2字节，剩余的14位“0xE22”表示为3618。
  字段六直接填应用层数据实体的数据长度即可，即不包含DSM报头的数据载荷长度，其大小为2字节，大端模式。
  字段七为应用层有效载荷，即经UPER编码后的应用层数据。

# 备注

  在上文中曾多次提及到大端模式，即对于一个多字节的数据，其高字节数据存放在低地址，而低字节数据存放在高地址，与小端模式(intel)正相反，
  假如有一个4字节的数据为 0x12 34 56 78（十进制：305419896，0x12为高字节，0x78为低字节），若将其存放于地址0x4000 8000中，则有：

![img](https://img-blog.csdnimg.cn/20210322211444691.png)
  如“网络层（DSMP）”一节中我们谈到的aid为3618的地图类应用，虽然其值为0x8E22,但是若我们的计算机默认是小端模式的，当经过如下赋值

```c
aid = 0x8e22;
```

  则实际DSM协议解析出来的数据却是“0x22 0x8E”,所以需要进行大端的转换，由于网络字节序一律为大端，而目前个人PC大部分都是X86的小端模式，因此网络编程中不可避免得要进行网络字节序和主机字节序之间的相互转换，下面是 socket 提供的转换函数，

```c
#define ntohs(n)     // 16位数据类型网络字节顺序到主机字节顺序的转换  
#define htons(n)     // 16位数据类型主机字节顺序到网络字节顺序的转换  
#define ntohl(n)     // 32位数据类型网络字节顺序到主机字节顺序的转换  
#define htonl(n)     // 32位数据类型主机字节顺序到网络字节顺序的转换
```

  或者可以声明一个大小为2的字节数组，手动将高字节数据放置低地址中去，如：

```c
byte aid[2];
aid[0] = 0x8e;
aid[1] = 0x22;
```

  更多关于大小端模式的介绍，[参考此篇博客。](https://blog.csdn.net/weixin_40315804/article/details/79283397)