## 1 #pragma once有什么作用？

- [C/C++ 中的 #pragma once 作用是什么？_程序员编程指南的博客-CSDN博客](https://blog.csdn.net/weixin_41055260/article/details/122994997)

为了避免同一个[头文件](https://so.csdn.net/so/search?q=头文件&spm=1001.2101.3001.7020)被包含（include）多次，C/C++中有两种宏实现方式：**一种是#ifndef方式**；**另一种是#pragma once方式**。

## 2 c++ namespace

- [详解c++的命名空间namespace - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/126481010)

在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间/名字空间/名称空间），可以更好地控制标识符的作用域。

## 3 c++ class

![img](https://www.runoob.com/wp-content/uploads/2015/05/cpp-classes-objects-2020-12-10-11.png)

## 4 C++之const std::string& s

- [C++之const std::string& s（传参时 const string& 相对 const string 的优势）_啊_是汪汪啊的博客-CSDN博客_const std::string&](https://blog.csdn.net/qq_34706266/article/details/88547095)

```c++
DepthViewer(const std::string& win);
```

首先::表示

1、类作用域操作符

“::”指明了成员函数所属的类，例如：M::f(s)就表示f（s）是类M的成员函数。

2、表示“域操作符”

例如：声明了一个类A，类A里声明了一个成员函数void f( )，但没有在类的声明里给出f的定义，那么在类外定义f时， 就要写成void A::f( )，表示这个f( )函数是类A的成员函数。

3、表示引用成员函数及变量，作用域成员运算符。

比：System::Math::Sqrt( ) 相当于System.Math.Sqrt( )

二、上述代码表示将字符串“**Depth**”赋给**string**引用对象**win**

三、传参时 const string& 相对 const string 的优势：主要在于传参时 const string&比const string更节省资源。

C++的值传递（pass-by-value）,是从调用的地方把值复制一遍传给函数，这样做有两个问题，第一，需要将实参拷贝到形参处，形成实参的副本，有时间和空间的开销，若实参为结构体或者类的话,那么时空开销将会非常大；第二、函数中对实参副本的修改并不会影响到函数调用位置实参的值。 
C++的引用传递（pass-by-reference）,一方面，参数传递的是把实参的地址拷贝到形参，这样形参和实参对应的是同一块儿内存地址，那么对形参的修改自然会反映到实参上；另一方面，C++中指针或者引用只占4字节，所以时空开销也能接受。

& 的目的是引用，避免再了复制一个std::string
const 是为了限定它只读

const string s 的话还是要再复制一次岂不是很浪费，既然已经是只读了可以直接用

因为 C++ 规定引用不能为空，所以一个函数传进来引用你就可以直接用，而传进来指针你还需要判断指针是否为空 
如果直接传值的话，对于对象就要新建一个临时对象——这个步骤需要调用复制构造函数，如果对象本身比较大的话就会造成很严重的资源浪费。而传引用就可以避免这一点——如果我们需要只读地访问一个对象的话使用常引用可以有效避免资源浪费。

## 5 c++ .h .cc

- [C++ 中头文件（.h）和源文件（.cc）的写法简述 - Cyril_Wu - 博客园 (cnblogs.com)](https://www.cnblogs.com/sylar5/p/6702483.html)

头文件（.h）和源文件（.cc）

**头文件(.h)：**

写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。

在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：

```
#ifndef CIRCLE_H
#define CIRCLE_H

//你的代码写在这里

#endif
```

这样做是为了防止重复编译，不这样做就有可能出错。至于CIRCLE_H这个名字实际上是无所谓的，你叫什么都行，只要符合规范都行。原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。

**源文件（.cc）：**

源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。那么当你需要用到自己写的头文件中的类时，只需要#include进来就行了。

## 6 *=

将变量值或属性值乘以表达式值，并将结果赋给变量或属性。

`*=` 运算符左侧的元素可以是简单的标量变量、属性或数组的元素。 变量或属性不能为[只读](https://docs.microsoft.com/zh-cn/dotnet/visual-basic/language-reference/modifiers/readonly)。

`*=` 运算符首先将表达式（位于运算符右侧）的值乘以变量或属性（位于运算符左侧）的值。 然后，运算符将该操作的结果赋给变量或属性。