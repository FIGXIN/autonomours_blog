- [如何破解汽车--CAN协议_worthsen的博客-CSDN博客](https://worthsen.blog.csdn.net/article/details/120241471)

# 1 介绍

汽车后装的辅助驾驶设备，一般需要知道汽车的CAN协议，各汽车厂家的CAN协议又是保密的，这时就需要破解，因为CAN协议是明文，所以破解也就轻松些。
![在这里插入图片描述](https://img-blog.csdnimg.cn/ab71f38f2f8e425fbedca86be2729638.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd29ydGhzZW4=,size_20,color_FFFFFF,t_70,g_se,x_16)

# 2 破解流程（以转速表为例）引自[2]

## 一辆车就是一个网络

- 一辆汽车由多台计算机组成，以控制发动机、变速器、窗户、锁、灯等。这些计算机被称为电子控制单元(ECU)，它们通过网络相互通信。例如，当你按下方向盘上的按钮来增加收音机的音量时，方向盘ECU向网络发送一个增加音量的命令，无线电ECU就会看到这个命令并采取相应的行动。
- 一辆车里有多个网络，通常至少有两个:
  a. 一个用于关键数据，如发动机和动力系统信息
  b. 另一种是不太重要的数据，比如无线电和门锁
- 关键网络使用快速可靠的协议，而非关键网络使用较慢、可靠性较低但成本较低的协议。网络的数量以及将哪些ecu连接在一起取决于汽车制造商、车型和年份。ECU还可以连接多个网络。

## 连接到网络

- 一些网络可以通过OBD-II端口访问。OBD-II适用于1996年以后在美国和2004年以后在欧洲生产的所有轿车和轻型卡车。
- 连接器位于驾驶员座位触手可及的位置。你可能需要取下一些塑料盖，但不用工具就可以使用。
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/06a47bc46076436fb1f5aa7fc3300445.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd29ydGhzZW4=,size_20,color_FFFFFF,t_70,g_se,x_16)
- OBD-II标准允许五种信令协议。由制造商决定使用哪一种。CAN是最受欢迎的，也是我们将要讨论的。它可以通过OBD-II连接器的**引脚6和14**访问。如果你的车有一个CAN总线，你会看到金属引线在引脚上，如上图所示。
- CAN总线是一种可靠的、高速的总线，用于发送关键数据。不幸的是，总线上的数据包不是标准化的，所以您需要将它们颠倒过来才能知道它们的意思。OBD-II标准还为特定于供应商的引脚留有空间，这些引脚可以用于特定于供应商的协议。这使得经销商更容易诊断问题。
- 在我的汽车(GM)上，我有一个标准的CAN总线在引脚6和14，和一个供应商特定的单线CAN总线在引脚1。标准CAN总线是一种可靠、高速(500kbps)的协议，也称为高速CAN (HS-CAN)。它用于关键数据。单线CAN总线(SW-CAN)或GMLAN速度较慢(33.3 kbps)，可靠性较差，但成本较低，因为它只使用一根线。此总线用于非关键数据。
- 如果你看到一个供应商特定的引脚，但不知道使用的是哪个协议，谷歌" OBD pinout "。还有低速CAN (LS-CAN)和中速CAN (MS-CAN)。MS-CAN通常在第3和第11针，在福特和沃尔沃汽车上以125 kbps的速度运行。

## 工具

你需要一台能够解读CAN数据的设备，以及分析数据的软件

## 硬件

- 为了接收和发送CAN包，您需要一个能够做到这一点的设备。您经常会遇到基于ELM327的设备。虽然它们有自己的用途，但对于黑客来说，它们是可怕的。它们的速度太慢，无法监控CAN总线。此外还有Kvaser、Peak或EMS Wünsche等高端设备。这些可以完成工作，但太过了，而且相当昂贵。
- 一些高端设备还要求你同时购买软件。USB2CAN是一个用于Linux的本地CAN接口，性价比很高。
  你也可以使用Cantact或CANUSB。然而，这些不是Linux中的本地CAN设备，而是使用基于ASCII的协议。这意味着它们的设置稍微复杂一些，性能也较差。另一方面，它们在多个操作系统中都得到了很好的支持。
- 我使用的CANalyze是我为自己的需求设计的。它类似于USB2CAN，因为它是一个便宜的本地CAN接口，但它使用了一个较新的微控制器，是开源的，可以使用开源工具构建。本教程的其余部分假设您使用的是本机CAN接口。

## 软件

要与设备通信，需要在Linux机器上安装can-utils包。你可以通过在Linux提示符中输入以下命令来实现:

```cpp
sudo apt-get install can-utils
```

CAN-utils使得发送、接收和分析CAN包非常容易。这些是我们将要使用的命令。

```cpp
cansniffer 只显示正在变化的报文
Candump 打印所有收到的数据包
Cansend 发送一个数据包
```

Linux通过SocketCAN在内核中内置CAN支持。这使得编写自己的附加程序变得很容易。你可以与[can总线](https://so.csdn.net/so/search?q=can总线&spm=1001.2101.3001.7020)交互，就像你与任何其他网络交互一样，即通过套接字。

## CAN bus

在开始破解之前，您应该对CAN总线的工作原理有一些了解。它由两根导线组成，并使用不同的信号。因为它是总线，多个设备可以连接到这两条线。当CAN帧在总线上发送时，它被所有ECU接收，但只有当它对ECU有用时才被处理。如果同时发送多个CAN帧，优先级最高的帧将获胜。一个CAN框架有三个部分与我们相关。

- 仲裁标识符
  消息的标识符。ECU使用它来决定是处理还是忽略接收到的帧。它还表示消息的优先级。编号越低优先级越高。例如，如果你是一个设计网络的工程师，你会给安全气囊部署的框架一个非常高的优先级或者一个低的仲裁ID。另一方面，对于用于门锁的数据，您可能会给出较低的优先级或较高的仲裁ID。
- 数据长度码 (DLC)
  数据字段的长度，以字节为单位。**一个CAN帧最多可以有8字节的数据**。
- 数据字段
  最多8字节的数据。

## 破解CAN协议

- 破解CAN总线的一般方法是生成您想要模拟的行为，并找到导致该行为的消息。例如，让我们假设你车上的车道保持辅助系统(LKAS)是垃圾，而你已经制作了自己的。
- 为了让它控制转向，你需要知道要发送什么信息。解决这个问题的方法是打开原来的LKAS，监控CAN总线并识别负责转动方向盘的包。一旦你确定了这些数据包，你就可以让你自己的LKAS把这些数据包发送到can总线来控制方向盘。
- 在我们的情况下，我们想要欺骗转速表，所以我们需要改变转速通过踩油门与汽车上和空挡，然后试图找到包负责改变转速。

## 设置

将CAN设备插入汽车的OBD-II端口和计算机的USB端口。在Linux提示符中运行以下命令启动CAN接口:

```cpp
sudo ip link set can0 up type can bitrate 500000
```

这将以500 kbps的比特率打开can0接口(如果你只有一个设备连接，总是can0)，这是标准的。

## 识别

当汽车关闭时，ecu通常处于睡眠状态，所以你需要打开汽车或将其置于辅助模式。你可以通过在Linux提示符中运行下面的命令查看原始can数据:

```cpp
candump can0
```

一旦接收到CAN数据，就会将其打印到屏幕上。然而，这是非常无组织的，很难看到哪些数据包对应于某个事件。你可以按ctrl+c来停止程序。为了使数据更具可读性，我们使用了cansniffer，它根据仲裁ID对数据包进行分组，并且只显示正在变化的数据包。为了启动它，在Linux提示符中运行命令:

```cpp
cansniffer -c can0
```

其中-c将更改的字节着色，can0是用来嗅闻的接口。移除固定数据包需要几秒钟。

您应该会看到类似下图的内容，尽管数字可能完全不同。
![在这里插入图片描述](https://img-blog.csdnimg.cn/4a4e6c40c1cb467fa51803be8bddc0e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd29ydGhzZW4=,size_20,color_FFFFFF,t_70,g_se,x_16)
第一列(delta)显示了以秒为单位的接收仲裁ID的数据包的速率。第二列(ID)包含仲裁ID。其余的字母数字列(data…)包含数据字节。如果数据是ASCII表示，它可以在右边看到，否则它是一个点。

当你在引擎运行时踩油门以提高转速时，屏幕上可能会出现新的CAN信息，或者现有的信息会发生变化。

我们需要找到一个CAN消息，其中变化的字节与RPM的变化相关。我们可以预期这个值将随着RPM的增加/减少而增加/减少。

canniffer中的第一个CAN帧似乎随RPM而变化，它是仲裁id为C9的帧。可能有多个包随RPM而变化，这只是第一个。
![在这里插入图片描述](https://img-blog.csdnimg.cn/cc11de51a6ec469e9e8668271667afce.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd29ydGhzZW4=,size_20,color_FFFFFF,t_70,g_se,x_16)
在此消息中有4个字节正在更改(红色)，但并非所有字节都必须指示RPM。第三个字节07的变化似乎与不同的RPM无关。最后一个字节是1B。
然而，只要我们把脚从油门上拿开，它就到了00。这将表明，它代表油门位置，而不是RPM。
最后是两个字节21 C0，它们似乎与RPM中的变化相对应。更重要的是，它是一个16字节整数，即当第二个字节C0溢出时，第一个字节21增加1。似乎21对应大约2000 RPM。当您将重播消息时，请注意这一点。

## 重播

一旦你有了一个候选，在Linux提示符中使用以下命令将它发送到CAN总线上:

```cpp
cansend can0 0C9#8021C0071B101000
```

其中帧的格式为 #{data}，必须用您自己的CAN消息替换。

您的汽车可以运行或配件模式。请确保使用引擎非空闲时获得的包，否则在引擎空闲时重放它不会看到任何变化。

如果只发送一次数据包，您可能不会看到仪器集群上有任何变化。这是因为ECU仍然以0.2秒的间隔在总线上连续发送原始消息，所以您的消息将被忽略。

回忆一下，速率是在canniffer的第一列给出的。有两种方法可以解决这个问题，除了断开生成这些消息的ECU。一种选择是以比当前正在发送的信息包更高的频率发送信息包。你可以在Linux提示符中运行以下命令:

```cpp
while true; do cansend can0 0C9#8021C0071B101000; sleep 0.002; done
```

并将CAN消息替换为您已确定的消息。按ctrl+c停止。

另一种选择是监视总线，每次检测到想要欺骗的包时，立即发送自己的包。这可以通过在Linux提示符中运行来实现:

```cpp
candump can0 | grep " 0C9 " | while read line; do cansend can0 0C9#8021C0071B101000; done
```

你需要用你识别的CAN消息和它的仲裁id分别替换CAN消息和0C9。您可以对这两种方法进行试验，看看哪一种效果更好。

如果转速表变了，干得好，你找到了!如果没有，则识别与RPM相关的下一条消息并重播它。

## 模糊测试

现在您已经有了在仪器集群上设置RPM的CAN帧，您可以使用发送的数据来查看发生了什么。我们已经注意到，与RPM对应的两个字节表现为一个16位整数，因此为了将转速表设置为8k RPM，我们在Linux提示符中运行以下命令:

```cpp
while true; do cansend can0 0C9#0080000000101000; sleep 0.002; done
```

结果是……
![在这里插入图片描述](https://img-blog.csdnimg.cn/7d3defc2a33846d4b27d89631b8acf88.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd29ydGhzZW4=,size_20,color_FFFFFF,t_70,g_se,x_16)
就是这样!您现在可以尝试控制速度计，收音机，灯，门锁等使用相同的方法。

## 可能的问题

虽然CAN总线是最流行的网络，但它不是唯一的网络。如果您不能在can总线上找到您要查找的消息，请尝试不同的网络。特别是非关键信息，如收音机、灯和门锁，可能会在不同的网络上。

如前所述，通过CAN传输的确切数据取决于汽车的制造商、型号和年份。有些汽车在CAN消息中使用计数器，以确保同一消息不会被多次处理。这稍微有点困难，但是你应该能够使用提供的信息来完成它。一些汽车还使用校验和来确保数据的完整性。计算这个校验和是很困难的。

当在总线上重放识别的数据包时，您的CAN到USB设备可能进入“总线关闭”状态。这是CAN标准的一部分，当设备遇到太多错误时就会发生。这种情况通常发生在交通繁忙的公共汽车上。为了解决这个问题，你可以尝试延迟和计时，也许可以尝试在将汽车置于辅助模式后立即重播消息，尝试等待一段时间，在汽车上尝试，等等。如果您已经确定哪些ECU连接到总线，您还可以拉他们的保险丝，以阻止他们发送消息和降低总线上的流量。

# 参考

1、《The Car Hacker’s Handbook》(https://docs.alexomar.com/biblioteca/thecarhackershandbook.pdf)
2、[How to hack a car — a quick crash-course](https://www.freecodecamp.org/news/hacking-cars-a-guide-tutorial-on-how-to-hack-a-car-5eafcfbbb7ec/)